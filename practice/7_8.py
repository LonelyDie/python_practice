import random

# Сравнение длины строки с числом 5
str = input()
if len(str) < 5:
    print("Длина ввода меньше 5 символов")
elif len(str) > 5:
    print("Длина ввода больше 5 символов")
elif len(str) == 5:
    print("Длина ввода составляет 5 символов")

# Угадай число
number = int(input("Я загадал(а) число от 1 до 10. Угадайте его "))
if number == 3:
    print("Вы победили!")
else:
    print("Вы проиграли")

# Поиск множителей числа
number1 = int(input("Enter a positive integer: "))
for i in range(1, number1 + 1):  # Ищем все делители числа
    if number1 % i == 0:  # Проверяем, делится ли число на i
        print(f"{i} is a factor of {number1}")  # Выводим делитель

# Многократно запрашиваем данные у пользователя
while True:  # Бесконечный цикл
    n = input()  # Ввод данных от пользователя
    if (n == "q") or (n == "Q"):  # Проверяем, ввёл ли пользователь "q" или "Q"
        break  # Если да, прерываем цикл

# Перебираем числа от 1 до 50 (включительно)
for i in range(1, 51):
    # Если число кратно 3, пропускаем его
    if i % 3 == 0:
        continue
    # Если число не кратно 3, выводим его
    print(i)

# Пытаемся получить ввод от пользователя
try:
    # Преобразуем ввод в целое число
    num = int(input("Enter an integer: "))
except ValueError:
    # Если произошла ошибка при преобразовании (не целое число), выводим сообщение
    print("That was not an integer")

try:
    # Запрашиваем у пользователя ввод строки
    str1 = input("Введите слово: ")

    # Запрашиваем у пользователя ввод числа и пытаемся преобразовать его в целое
    num = int(input("Введите число: "))

    # Проверяем, что индекс не выходит за границы строки
    if num < 0 or num >= len(str1):
        # Если индекс вне диапазона, выводим сообщение об ошибке
        print("Индекс выходит за границы массива")
    else:
        # Если индекс корректный, выводим символ по указанному индексу
        print(f"Символ по индексу {num}: {str1[num]}")

# Обрабатываем случай, когда введено не целое число
except ValueError:
    print("That was not an integer")  # Сообщаем, что введённое значение не является целым числом

# Функция roll() моделирует бросок кубика с числами от 1 до 6
def roll():
    # Используем randint() для генерации случайного числа от 1 до 6
    a = random.randint(1, 6)
    # Возвращаем результат броска кубика
    return a

# Вызов функции roll() и вывод результата
result = roll()  # Получаем результат броска
print(result)  # Выводим результат на экран

# Функция cube() моделирует 10 000 бросков игрального кубика
def cube():
    total = 0  # Переменная для накопления суммы всех выпавших чисел
    for i in range(10_000):  # Цикл повторяется 10 000 раз
        a = random.randint(1, 6)  # Генерируем случайное число от 1 до 6 (результат броска кубика)
        total += a  # Добавляем полученное число к общей сумме
    return total  # Возвращаем итоговую сумму всех бросков

# Вызов функции cube() и сохранение результата (сумма всех бросков)
result1 = cube()
# Вычисляем среднее значение, деля сумму на 10 000, и выводим результат
print(result1 / 10_000)

# Функция для подбрасывания монеты
def coin_flip():
    # Генерируем случайное число: 0 - "heads" (орел), 1 - "tails" (решка)
    if random.randint(0, 1) == 0:
        return "heads"
    else:
        return "tails"

# Флаги, чтобы отслеживать, что оба результата (heads и tails) выпали
heads_seen = False
tails_seen = False

throws_count = 0  # переменная для подсчета числа бросков в одном эксперименте

# Бросаем монету до тех пор, пока не выпадет и heads, и tails хотя бы по одному разу
while not (heads_seen and tails_seen):
    result2 = coin_flip()  # подбрасываем монету
    throws_count += 1  # увеличиваем количество бросков
    if result2 == "heads":  # если выпал "орел"
        heads_seen = True
    else:  # если выпала "решка"
        tails_seen = True

# Выводим общее количество бросков для этого эксперимента
print(throws_count)

# Моделирование выборов
total_wins_A = 0  # Счётчик побед кандидата A в выборах (2+ участка)

# Запускаем 10 000 симуляций выборов
for i in range(10_000):
    count_wins_A = 0  # Счётчик побед A на отдельных участках (сбрасывается перед каждой симуляцией)

    # Определяем, победил ли A на каждом из трёх участков
    if random.randint(1, 100) <= 87:  # Участок 1 (A побеждает с вероятностью 87%)
        count_wins_A += 1
    if random.randint(1, 100) <= 65:  # Участок 2 (A побеждает с вероятностью 65%)
        count_wins_A += 1
    if random.randint(1, 100) <= 17:  # Участок 3 (A побеждает с вероятностью 17%)
        count_wins_A += 1

    # Если кандидат A победил как минимум на двух участках, записываем победу в общий счётчик
    if count_wins_A >= 2:
        total_wins_A += 1

# Вычисляем процент случаев, когда A выиграл выборы, и выводим результат
percentage_A_wins = (total_wins_A / 10_000) * 100
print(f"Кандидат A победил в {percentage_A_wins:.2f}% выборов")
